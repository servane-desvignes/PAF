/* autogenerated by Processing revision 1292 on 2023-06-30 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Flocking extends PApplet {

Savana savana; // l'ensemble des agents (proies + prédateurs)
Box[] carre=new Box[3]; 
Button launchButton;
int Xmaxgraph = PApplet.parseInt(1280-(1280/4));
int nbInitWildebeest;
int nbInitZebra;
StatTracker statTracker;
static int desireAssociation;


/** Met en place l'interface et les agents*/
public void setup() {
  /* size commented out by preprocessor */;
  savana = new Savana();
  statTracker = new StatTracker( savana, 1 ); // permettra de suivre les donnees pour faire le graphe
  
  launchButton =  new Button(1020, 170);

  // Les trois "handles" pour choisir les populations initiales et l'association
  carre[0] = new Box(width*3/4 +20, 90, 0, 8, carre);
  carre[1] = new Box(width*3/4 +20, 140, 0, 8, carre);
  carre[2] = new Box(width*3/4 +20, 190, 0, 8, carre);
  launchButton =  new Button(1020, 220);
}

/** Dessine l'interface et les agents a chaque frame **/

public void draw() {
  background(152, 190, 100);

  //Les polices d'ecriture pour les instructions
  PFont Titre = createFont("DevanagariMT-48", 30);
  PFont sousTitre = createFont("HiraginoSans-W1-48", 25);

  //La ligne démarquant les instructions de la simulation
  stroke(0);
  line(Xmaxgraph, 0, Xmaxgraph, height);

  // Populations initiales , couleurs a changer plus tard

  textSize(20);
  fill(0);
  textFont(Titre);
  text("Initial Population", width*3/4 +10, 30);
  launchButton.update();
  launchButton.dessin();

  //variable de regrouppement
  fill(0);//noir
  text("Association             (en %)", width*3/4 +10, 180);
  text(carre[2].AssociationPourcent(), width*3/4 +200, 180);

  //proies
  textFont(sousTitre);

  fill(245, 198, 215);//rose
  text("Wildebeest", width*3/4 +10, 70);

  fill(0, 128, 0);//rose
  text("Zebra", width*3/4 +10, 125);

  fill(0);
  text(carre[0].preyNumber(), width*0.75f+200, 70);
  text(carre[1].preyNumber(), width*3/4 +200, 125);

  //partie bar pour avoir conditions initiales :
  fill(0);
  line(width*3/4 +20, 90, width*3/4 +300, 90);
  line(width*3/4 +20, 140, width*3/4 +300, 140);
  //line(width*3/4 +20, 190, width*3/4 +300, 190);

  for (int i =0; i<2; i++) {
    carre[i].update();
    carre[i].display();
  }
  
  //apres utilisation : false
  if (firstMousePress) {
    firstMousePress = false;
  }
  
  //instructions pour les prédateurs

  fill(0);
  textFont(Titre);
  text("Predator Population", width*3/4 +10, height*0.35f+30);
  
  textFont(sousTitre);
  text("Right click to add", width*3/4 +10, height*0.35f+80);
  text("a cheetah", width*3/4 +10, height*0.35f+110);
  //text("Left click to add a zebra", width*3/4 +10, height*0.35+150);
  
  //Partie predateurs
  fill(0);
  textFont(Titre);
  text("Graphe et statistique", width*3/4 +10, height*0.35f+210);
  
  stroke(0, 255, 0);

  //bouton de lancement
  if (boutonAppuye && click==1) {
    println("lancement");

    BoutonAppuye(carre[0].preyNumber(), carre[1].preyNumber());
    
    statTracker.startTracking();
    boutonAppuye=false;
  }

  //lancement des agents
  savana.run();
  
  //partie statistiques et data
  statTracker.refresh();
  statTracker.renderGraphs();
}

/**Lancement de la simulation lorsque le bouton "Launch" est appuyé
*@param nWildeBeest population de gnous rentrée dans la barre handle
*@param nZebra population de zebres
* ajoute 4 predateurs au debut 
**/

public void BoutonAppuye(int nWildeBeest, int nZebra) {
  for (int i = 0; i <nWildeBeest; i++) {
    int r1=PApplet.parseInt(random(7));
    //int r2=int(random(7));
    savana.addBoid(new Wildebeest(r1*width/6, r1*height/6));
    //savana.addBoid(new Wildebeest(r2*width/6, r2*height/6));
  }
  for (int i = 0; i < 4; i++) {
    int r1=PApplet.parseInt(random(7));
    int r2=PApplet.parseInt(random(7));
    savana.addBoid(new Cheetah(r1*width/6, r2*height/6));
  }

  for (int i = 0; i < nZebra; i++) {
    int r1=PApplet.parseInt(random(7));
    //int r2=int(random(7));
    savana.addBoid(new Zebra(r1*width/6, r1*height/6));
  }
}


public void mousePressed() {
  if (!firstMousePress) {
    firstMousePress = true;
  }
  launchButton.testSouris();
}


public void mouseClicked() {
  if (mouseButton == RIGHT && mouseX<Xmaxgraph  ) {
    savana.addBoid(new Cheetah(mouseX, mouseY));
  }
}


public void keyPressed() {
  if (key == CODED) {
    if (keyCode == UP) {
      savana.addBoid(new StudyCheetah(mouseX, mouseY));
    } else if (keyCode == DOWN) {
      int total = savana.number();
  println("The total number of animals is: " + total);
    } 
  } else {
    savana.addBoid(new Zebra(mouseX, mouseY));
  }
}

public void mouseReleased() {
  for (int i = 0; i < carre.length; i++) {
    carre[i].releaseEvent();
  }
}
// The Boid class

abstract class Boid {

  //parametre regissant le mouvement d'un agent
  PVector position;
  PVector velocity;
  PVector acceleration;

  //la taille d'un agent
  float r;

  float maxforce;    // Maximum steering force
  float maxspeed;  // Maximum speed

  boolean alive; // true si l'agent est en vie

  float rangeVision; // son champ de vision

  float x;
  float y;

  float rangeAudition; // champ d'audition

  int timeAlive=0; //le temps de vie d'un agent

  boolean isTargeted; // true si il est attaque par un predateur

  PVector direction = velocity;

  int lifetime;

  /**Constructeur de la classe Boid
   *@param x 1 axe de position
   *@param y 1 axe de position
   *@param maxforce maximum steering force
   *@param rangeVision champ de vision
   *@param rangeAudition champ d'audition
   **/

  Boid(float x, float y, float r, float maxforce, float maxspeed, float rangeVision, float rangeAudition) {
    acceleration = new PVector(0, 0);
    float angle = random(TWO_PI);
    velocity = new PVector(cos(angle), sin(angle));
    this.x=x;
    this.y=y;

    position = new PVector(x, y);
    this.r = r;
    this.maxspeed = maxspeed;
    this.maxforce = maxforce;
    this.rangeVision=rangeVision;
    alive = true;
    this.rangeAudition = rangeAudition;

    lifetime = 0;
  }

  /** Modifie les attributs lorsque l'agent est tué par un prédateur **/

  public void killed() {
    this.alive=false;
    this.isTargeted=false;
  }


  /** Comportement du boid lors du lancement de la simulationi **/

  public void run(ArrayList<Boid> boids) {
    if (alive) lifetime++;
    this.timeAlive++;
    behavior(boids);
    update();
    borders();
    render();
  }

  /** Applique une force au boid **/

  public void applyForce(PVector force) {
    acceleration.add(force);
  }

  /** Le boid arrete tout mouvement **/

  public void stayStill() {
    acceleration.mult(0);
    velocity.mult(0);
  }

  /** Calcule la distance entre deux boids **/

  public float distTo(Boid b) {
    return PVector.sub(b.position, this.position).mag();
  }

  public float distanceTo(PVector p) {
    return PVector.sub(p, this.position).mag();
  }

  /** Modifie l'apparence du boid**/

  public abstract void render();

  /** Decrit le comportement du boid **/

  public abstract void behavior(ArrayList<Boid> boids);

  /** Met a jour le boid **/

  public void update() {
    velocity.add(acceleration);
    velocity.limit(maxspeed);
    position.add(velocity);
    acceleration.mult(0);
    if (!this.alive) {
      savana.remove(this);
    }
  }

  public boolean isAlive() {
    return alive;
  }

  /** Calcul et applique une force vers une proie **/

  public PVector seek(PVector target) {
    PVector desired = PVector.sub(target, position);  // vecteur entre la proie et le predateur
    desired.normalize();
    desired.mult(maxspeed);
    PVector steer = PVector.sub(desired, velocity);
    steer.limit(maxforce);  //limiter la force a la force maximale 
    return steer;
  }

  // Comportement torique des agents
  public void borders() {
    if (position.x < -r) position.x = width*0.75f+r-5;
    if (position.y < -r) position.y = height+r;
    if (position.x > width*0.75f-5+r) position.x = -r;
    if (position.y > height+r) position.y = -r;
  }

  /** Separe les agents trop prochese entre eux **/
  
  public abstract PVector separate (ArrayList<Boid> boids);
  
  /** Aligner les agents entre eux **/
  
  public abstract PVector align(ArrayList<Boid> boids);
  
  /** Avoir comportement uniforme entre agents assez proches **/
  public abstract PVector cohesion(ArrayList<Boid> boids);


  /** Les methodes suivantes reposent sur le comportement a liaison dynamique de Java 
  * On utilise l'heritage de classe pour redefinir ces methodes qui renverront true dans les classes respectives
  * Ainsi ces methodes nous permettrons de connaitre le type dese agents sans utiliser typeOf ou de switch **/
  
  public boolean isZebra() {
    return false;
  }

  public boolean isPredator() {
    return false;
  }

  public boolean isPrey() {
    return false;
  }

  public boolean isCheetah() {
    return false;
  }

  public boolean isWildebeest() {
    return false;
  }
  
  public abstract boolean isSameSpecies(Boid other);
}
static boolean firstMousePress = false;

//* classe des "handles" qui permettent a l'utilisateur de manipuler les conditions initiales

class Box {

  int x, y; //coordonnees du debut de la ligne

  int boxx, boxy; // coordonnees de la boite

  int stretch; // distance entre le debut de la ligne et la boite

  int size; // taille de la boite

  boolean over; // true si la souris est au dessus du carré

  boolean press; // true si le carré est cliqué par la souris

  boolean locked = false; // bloque les autres carrés

  boolean otherslocked = false;

  Box[] others; // autres carres

  Flocking flock; // troupeau d'agents

  /** Constructeur de la classe **/

  Box(int ix, int iy, int il, int is, Box[] o) {
    x = ix;
    y = iy;
    stretch = il;
    size = is;
    boxx = x+stretch - size/2;
    boxy = y - size/2;
    others = o;
  }

  /** Met a jour la position du carré **/

  public void update() {
    boxx = x+stretch;
    boxy = y - size/2;
    for (int i=0; i<others.length; i++) {
      if (others[i].locked == true) {
        otherslocked = true;
        break;
      } else {
        otherslocked = false;
      }
    }
    if (otherslocked == false) {
      overEvent();
      pressEvent();
    }
    if (press) {
      stretch = lock(0, mouseX-x, 280);
    }
  }

  /** Detecte si la souris est au dessus  **/
  
  public void overEvent() {
    if (overRect(boxx, boxy, size, size)) {
      over = true;
    } else {
      over = false;
    }
  }

  /** Detecte si l'utilisateur clique dessus **/ 
  
  public void pressEvent() {
    if (over  && firstMousePress || locked) {
      press = true;
      locked = true;
    } else {
      press = false;
    }
  }

  public void releaseEvent() {
    locked = false;
  }

  /** Affiche le carre **/ 
  
  public void display() {
    line(x, y, boxx, y);
    fill(255);
    stroke(0);
    rect(boxx, boxy, size, size);
    if (over || press) {
      line(boxx, boxy, boxx+size, boxy+size);
      line(boxx, boxy+size, boxx+size, boxy);
    }
  }

  /** Detecte si la souris et au dessus d'un carre quelconque **/
  
  public boolean overRect(int x, int y, int width, int height) {
    if (mouseX >= x && mouseX <= x+width &&
      mouseY >= y && mouseY <= y+height) {
      return true;
    } else {
      return false;
    }
  }

  /** Permet de bloquer le carre si il depasse la lignee **/
  
  public int lock(int val, int minv, int maxv) {
    return  min(max(val, minv), maxv);
  }

  /** Renvoie le nombre choisi par l'utilisateur **/
  
  public int preyNumber() {
    return (int) ((stretch) * 300 /280);
  }
  
  public int AssociationPourcent() {
    return (int) ((stretch) * 100 /280);
  }

}
static boolean boutonAppuye=false;
static int click=0;

/**Classe des boutons appuyables  **/

class Button {

  boolean rectOver=false ;

  int rectX, rectY; // coordonnees du bouton

  int largeur=70;
  int longueur=200;

  int rectHighlight=color(65, 147, 81); // couleur quand on passe la souris dessus

  int rectColor = color(28, 103, 42); // couleur normale sinon

  PFont sousTitre = createFont("HiraginoSans-W1-48", 17); // police du texte au dessus


  /** Constructeur de la classe **/

  Button(int rectX, int rectY) {
    this.rectX=rectX;
    this.rectY=rectY;
  }

  /** Met a jour l'apparence du bouton **/

  public void update() {
    if (overRect(rectX, rectY, longueur, largeur) ) {
      rectOver = true;
    } else {
      rectOver=false;
    }
  }

  /** Indique si la souris est au dessus du bouton **/

  public boolean overRect(int x, int y, int width, int height) {
    if (mouseX >= x && mouseX <= x+width &&
      mouseY >= y && mouseY <= y+height) {
      return true;
    } else {
      return false;
    }
  }

  /** Dessine le bouton lorsque la méthode est appelée a chaque frame **/

  public void dessin() {
    if (rectOver) {
      fill(rectHighlight);
    } else {
      fill(rectColor);
    }
    stroke(153);
    rect(rectX, rectY, longueur, largeur);
    fill(255);
    textFont(sousTitre);
    text("Launch Simulation", rectX +20, rectY + 41);
  }

  /** Verifie et compte le nombre de fois ou l'utilisateur clique sur le bouton, afin de ne lancer la simulation qu'une fois **/

  public void testSouris() {
    if (rectOver) {
      //currentColor = rectColor;
      boutonAppuye=true;
      click+=1;
    }
  }
}
class Cheetah extends Predator {
  float rangeVision=0;
  float rangeAudition=0;

  Cheetah(float x, float y) {
    super(x, y, 4, 0.05f, 3, 100, 30, 100);
  } // les argument sont (x,y,r,f,v,rV,dminkill,rA)


  @Override public 
    void behavior(ArrayList<Boid> boids) {
    if (this.timeAlive<0.1f*starvingTime || savana.getPreys().size()==0) {
      this.stayStill();
    } else {
      if (this.hasAPrey) {
        PVector direction = seek(this.target.position);
        applyForce(direction);
        if (distanceToPrey(this.target)<dMinKill) {
          this.target.killed();
          println("prey killed prey population remaining =" + savana.getPreys().size());
          this.hasAPrey = false;
          this.timeAlive = 0;
          this.target.isTargeted=false;
          println("l'énergie est " + this.energy());
        }
      } else {
        PVector dir = seek(savana.wildebeestCenter());
        applyForce(dir.mult(1));
        this.target = findATarget();
        for (Prey p : savana.getPreys()) {

          if ((canBeSeen( p) || canBeHeard( p)) && p.numberOfNeighboors()<3 && !p.isTargeted) {
            println(this +" is seeing " +this.target);
            this.target = p;
            p.isTargeted=true;
            this.hasAPrey=true;
          }
        }
      }
    }
    if (this.timeAlive>starvingTime) {
      this.alive = false;
    }
  }



  public float energy() {
    return ((this.starvingTime-this.timeAlive)/this.starvingTime);
  }


  public PVector randomVector() {
    float r = random(1000);
    float x = cos((r/1000.0f)*2*PI);
    float y = sin((r/1000.0f)*2*PI);
    PVector P =new PVector(x, y);
    return   P;
  }



  public Prey findATarget() {
    ArrayList<Prey> preys = savana.getPreys();
    Prey victim = closestPrey(preys);
    Prey isolatedVictim = savana.MostIsolateWildebeest();
    if (PVector.sub(position, victim.position).mag()<PVector.sub(position, isolatedVictim.position).mag()) {
      return victim;
    }
    return isolatedVictim;
  }

  public void render() {
    // Draw a triangle rotated in the direction of velocity
    float theta = velocity.heading() + radians(90);
    // heading2D() above is now heading() but leaving old syntax until Processing.js catches up
    if (this.hasAPrey) {
      fill(200, 0, 0);
      noStroke();
      pushMatrix();
      translate(position.x, position.y);
      rotate(theta);
      beginShape(TRIANGLES);
      vertex(0, -r*2);
      vertex(-r, r*2);
      vertex(r, r*2);
      endShape();
      popMatrix();
    } else {
      fill(100, 0, 0);
      noStroke();
      pushMatrix();
      translate(position.x, position.y);
      rotate(theta);
      beginShape(TRIANGLES);
      vertex(0, -r*2);
      vertex(-r, r*2);
      vertex(r, r*2);
      endShape();
      popMatrix();
    }
  }

  @Override public 
    boolean isCheetah() {
    return true;
  }
  
  @Override public 
  boolean isSameSpecies(Boid other) { return other.isCheetah(); }
}
/**
  * Custom class for displaying information in a graph format
  */
class Graph {
 
  boolean toggleLogging = false;
  
  /********** FIELDS **********/
  
  int graphWidth;          // Width of the graph
  int graphHeight;         // Height of the graph
  int margin;              // Margin around the graph
  PVector graphOrigin;     // Bottom left of the graph
  
  int red   = 50;          // RGB color of the curve
  int green = 50;          // 
  int blue  = 200;         //
  
  FloatList xData;         // Bottom axis data
  FloatList yData;         // Left axis data
  
  float xDistortion;       // How distorted the xData is for it to fit
  float yDistortion;       // How distorted the yData is for it to fit
  boolean[] axisToDistort;
  
  boolean dataFilled;
  
  /********** CONSTRUCTORS **********/
  
  Graph ( PVector graphOrigin , int graphWidth , int graphHeight , int margin) {
    
    this.graphOrigin = graphOrigin;
    this.graphWidth = graphWidth;
    this.graphHeight = graphHeight;
    this.margin = margin;
    dataFilled = false;
    
  }
  
  Graph ( int graphOriginX , int graphOriginY , int graphWidth , int graphHeight , int margin ) {

    this.graphOrigin = new PVector ( graphOriginX , graphOriginY );
    this.graphWidth = graphWidth;
    this.graphHeight = graphHeight;
    this.margin = margin;
    dataFilled = false;
    
  }
  
  /********** DATA SETTERS **********/
  
  /**
    * Sets the data fields with the given ArrayLists. If there's a dimension
    * problem, nothing happens and it returns false
    */
  public boolean fillData ( FloatList xData , FloatList yData ) {
    
    if (toggleLogging) System.out.println(printType() + " - Filling data fields");
    
    if ( xData.size() != yData.size() ) return false;
    
    else {
      
      this.xData = xData;
      
      if (xData == yData) {
        
        FloatList tmp = new FloatList();
        tmp = yData.copy();
        this.yData = tmp;
        
      } else this.yData = yData;
      
      levelData();
      
      dataFilled = true;
      
      return true;
      
    }
    
  }
  
  /**
    * Sets the xData field with the given ArrayList. If there's a dimension
    * problem, nothing happens and it returns false
    */
  public boolean fillXData ( FloatList xData ) { return fillData ( xData , this.yData ); }
  
  /**
    * Sets the yData field with the given ArrayList. If there's a dimension
    * problem, nothing happens and it returns false
    */
  public boolean fillYData ( FloatList yData ) { return fillData ( this.xData , yData ); }
  
  /********** LEVELLING **********/
  
  /**
    * Makes sure all the data fits in the graph
    */
  private void levelData() {
    
    if (toggleLogging) System.out.println(printType() + " - Filling display data fields");
    
    if (xData.size() == 0 ||yData.size() == 0) return;
    
    distortData(refreshDistortion());
    
  }
  
  /**
    * Computes the required distortion values to make the data fit in the graph
    * Returns a bool[2] that informs weither the distrotion could be calculated
    * for x ([0]) and y ([1])
    */
   public boolean[] refreshDistortion () {
    
    if (toggleLogging) System.out.println(printType() + " - Refreshing distortion fields");
    
    boolean[] res = new boolean[2];
    float maxX = xData.get(0);
    float maxY = yData.get(0);
    
    for (int i = 1 ; i < xData.size() ; i++) {
      
      if (xData.get(i) > maxX) maxX = xData.get(i);
      if (yData.get(i) > maxY) maxY = yData.get(i);
      
    }
    
    if ( maxX != 0 ) {
     
      xDistortion = graphWidth  / maxX ;
      res[0] = true;
      
    } else res[0] = false;
      
    if ( maxY != 0 ) {
     
      yDistortion = graphHeight  / maxY ;
      res[1] = true;
      
    } else res[1] = false;
    
    return res;
    
  }
  
  /**
    * Applies the current distortion settings to all elements of each data set
    */
  private void distortData(boolean[] axisToDistort) {
    
    if (toggleLogging) System.out.println(printType() + " - Refreshing display data fields");
    
    for (int i = 0; i < xData.size(); i++) {
      
      if (axisToDistort[0]) xData.mult( i , xDistortion );
      if (axisToDistort[1]) yData.mult( i , yDistortion );
      
    }
    
    this.axisToDistort = axisToDistort;
    
  }
  
  public boolean[] getAxisToDistort() { return axisToDistort; }
  
  public float[] getDistortion() {
    float[] tmp = new float[2];
    tmp[0] = xDistortion;
    tmp[1] = yDistortion;
    return tmp;
  }
  
  /********** RENDERING **********/
  
  /**
    * Displays the graph on the screen. It will just be a blank rectangle
    * if the data fields aren't set.
    */
  public boolean render () {
    
    if (toggleLogging) System.out.println(printType() + " - Rendering");
    
    renderBackground();
           
    if ( dataFilled ) {
      
      renderCurve();
      
      return true;
      
    } else return false;
    
  }
  
  public void renderCurve () {
    
    stroke ( red , green , blue );
      
      for ( int i = 0 ; i < xData.size() - 1 ; i++ ) {
        
        line ( (int) graphOrigin.x + xData.get(i)   ,
               (int) graphOrigin.y - yData.get(i)   ,
               (int) graphOrigin.x + xData.get(i+1) ,
               (int) graphOrigin.y - yData.get(i+1) );
        
      }
    
  }
  
  public void renderBackground () {
    
    fill ( 255 );
    stroke ( 100 );
    
    rect ( (int) graphOrigin.x - margin , 
           (int) graphOrigin.y - graphHeight - margin ,
           graphWidth  + 2 * margin ,
           graphHeight + 2 * margin );
           
  }
  
  public void setCurveColor ( int red , int green , int blue ) {
    
    this.red = red;
    this.green = green;
    this.blue = blue;
    
  }
  
  public String printType() { return "Graph";}
 
}

class Pack {
  ArrayList<Cheetah> cheetahs; // An ArrayList for all the boids

  Pack() {
    cheetahs = new ArrayList<Cheetah>(); // Initialize the ArrayList
  }

  public void run(ArrayList<Boid> boids) {
    for (Cheetah c : cheetahs) {
      c.run(boids);  // Passing the entire list of boids to each boid individually
    }
  }

  public void addCheetah(Cheetah c) {
    cheetahs.add(c);
  }
}
// classe des prédateurs

abstract class Predator extends Boid {

  ArrayList<Prey> Eaten;
  float dMinKill;
  float alpha = PI/3; // caractérise le champs de vision des prédateurs
  boolean hasAPrey=false;
  Prey target;
  float energy;
  float initialEnergy=1;
  int starvingTime=1000;
  boolean starving = false ;
  boolean isTargeted=false;


  Predator(float x, float y, float r, float maxforce, float maxspeed, float rangeVision, float dMinKill, float rangeAudition) {
    super(x, y, r, maxforce, maxspeed, rangeVision, rangeAudition);
    this.dMinKill = dMinKill;
  }

  public boolean canBeSeen(Prey b) {
    PVector P = new PVector(b.x, b.y);
    PVector delta=PVector.sub(P, this.position);
    float dist = delta.mag();
    if (dist>this.rangeVision) {
      return false;
    }
    float beta = abs(PVector.angleBetween(this.velocity, delta));
    if ( (beta>alpha/2)) {
      return false;
    }
    return true;
  }


  public float energyDecreasement() {
    return PApplet.parseFloat(1-(this.timeAlive/this.starvingTime));
  }


  public void starvation() {
    if (energyDecreasement()<0.5f) {
      this.starving = true;
    }
  }


  public boolean canBeHeard(Prey b) {
    PVector P = new PVector(b.x, b.y);
    PVector delta=PVector.sub(P, this.position);
    float dist = delta.mag();
    if (dist>this.rangeAudition) {
      return false;
    }
    return true;
  }





  /*
  Prey closestPrey(ArrayList<Prey> preys) {
   float dMin = PVector.sub(position, preys.get(0).position).mag();
   int i = 0;
   for (Prey p : preys) {
   PVector delta = PVector.sub(position, p.position);
   float distance = delta.mag();
   if (distance<dMin) {
   dMin=distance;
   i++;
   }
   }
   return preys.get(i);
   }*/

  public Prey closestPrey(ArrayList<Prey> preys) {
    float dMin = PVector.sub(position, preys.get(0).position).mag();
    int imin=0;
    for (int i =0; i<preys.size(); i++) {
      Prey p =preys.get(i);
      if (PVector.sub(position, p.position).mag()<dMin || (PVector.sub(position, p.position).mag()==dMin && p.isWildebeest() )) { // si cas d'egalité des distances, le predateur prefere chasser les cheetahs
        dMin = PVector.sub(position, p.position).mag();
        imin=i;
      }
    }
    this.hasAPrey=true;
    return preys.get(imin);
  }



  public float distanceToPrey(Prey p) {
    return PVector.sub(position, p.position).mag();
  }


  /* boolean tooCloseToCenter(){
   PVector c = savana.wildebeestCenter();
   if(distancetTo(c)<
   }*/


  public float distanceToClosestPrey(ArrayList<Prey> preys) {
    return distanceToPrey(closestPrey(preys));
  }

  @Override public 
    PVector separate(ArrayList<Boid> boids) {
    return new PVector(0, 0);
  }

  @Override public 
    PVector align(ArrayList<Boid> boids) {
    return new PVector(0, 0);
  }

  @Override public 
    PVector cohesion(ArrayList<Boid> boids) {
    return new PVector(0, 0);
  }




  @Override public 
    boolean isPredator() {
    return true;
  }
}
//classe des proies

abstract class Prey extends Boid {

  float alpha = 5*PI/6; //caractérise le champs de vision de la proies

  float desiredSeparationPrey = 25.0f; // distance de separation d'une autre proie

  float desiredSeparationPredator = 2000.0f; // distance de separation entre proie et predateur ( plus grande que la precedente pour modeliser la fuite des proies )

  boolean isTargeted=false; // true si elle est attaquee par un predateur

  boolean isIsolated=false; // true si l'agent est isolé


  /** Constructeur de la classe **/

  Prey(float x, float y, float r, float maxforce, float maxspeed, float rangeVision, float rangeAudition) {
    super(x, y, r, maxforce, maxspeed, rangeVision, rangeAudition);
  }

  /** Methode reposant sur le comportement a liaison dynamique de java
   * Nous indique si l'agent est une proie
   **/

  @Override public 
    boolean isPrey() {
    return true;
  }

  /** Methode renvoyant true si l'agent this est visible par l'agent b ( utilisé sur des predateurs )
   @param b l'agent dont on verifie le champ de vision
   **/

  public boolean canBeSeen(Boid b) {
    PVector P = new PVector(b.x, b.y);
    PVector delta=PVector.sub(P, this.position);
    float dist = delta.mag();
    if (dist>this.rangeVision) {
      return false;
    }
    float beta = abs(PVector.angleBetween(this.velocity, delta));
    float gamma = PI-alpha;
    if (beta>PI-gamma) {
      return false;
    }
    return true;
  }

  /** Methode renvoyant true si l'agent this peut etre entendu par l'agent b
   *@param b l'agent dont on verifie le champ d'audition
   **/

  public boolean canBeHeard(Boid b) {

    PVector P = new PVector(b.x, b.y);
    PVector delta=PVector.sub(P, this.position);
    float dist = delta.mag();
    if (dist>this.rangeAudition) {
      return false;
    }
    return true;
  }

  /** Methode pour compter le nombre de voisins. Utilisée pour verifier si une proie est isolée , c'est-a-dire son nombre de voisins est inferieur a 3 **/

  public int numberOfNeighboors() {
    ArrayList<Prey> preys = savana.getPreys();
    preys.remove(this);
    int i = 0;
    for (Prey p : preys) {
      if (this.distTo(p)<5*this.r) { // On considere que deux agents sont proches si leur distance est inferieur a 5 fois leur taille
        i++;
      }
    }
    return i;
  }

  /** Decrit le comportement des proies **/

  public void behavior(ArrayList<Boid> boids) {

    PVector sep = separate(boids);   // Separation
    PVector ali = align(boids);      // Alignment
    PVector coh = cohesion(boids);   // Cohesion
    if (this.numberOfNeighboors()<3) {
      this.isIsolated = true;
    }
    if (this.numberOfNeighboors()>2) {
      this.isIsolated = false;
    }
    // coefficiente arbitrairement les forces
    sep.mult(1.5f);
    ali.mult(0.5f);
    coh.mult(0.3f);
    // ajoute les forces a l'acceleration
    applyForce(sep);
    applyForce(ali);
    applyForce(coh);
  }

  /** Alignement
   *Pour tous les boids proches, calcule la vitesse moyenne
   **/

  @Override public 
    PVector align (ArrayList<Boid> boids) {
    float neighbordist = rangeVision;
    PVector sum = new PVector(0, 0);
    int count = 0;
    for (Boid other : boids) {
      float d = PVector.dist(position, other.position);
      if ((d > 0) && (d < neighbordist)) {
        sum.add(other.velocity);
        count++;
      } else if (this.isPrey()) {
        float alignementPourcentage = Flocking.desireAssociation/100;
        if ((d > 0) && (d < neighbordist)) {
          sum.add(PVector.mult(other.velocity, alignementPourcentage));
          count++;
        }
      }
    }

      if (count > 0) {

        sum.div((float)count);
        // First two lines of code below could be condensed with new PVector setMag() method
        // Not using this method until Processing.js catches up
        // sum.setMag(maxspeed);

        // Implement Reynolds: Steering = Desired - Velocity
        sum.normalize();
        sum.mult(maxspeed);
        PVector steer = PVector.sub(sum, velocity);
        steer.limit(maxforce);
        return steer;
      } else {
        return new PVector(0, 0);
      }
    
  }

  /** Cohesion
   * Pour le centre de tous les boids proches , calcule le vecteur qui mene a cette position
   **/

  @Override public 
    PVector cohesion (ArrayList<Boid> boids) {
    float neighbordist = rangeVision;
    PVector sum = new PVector(0, 0);   // Start with empty vector to accumulate all positions
    int count = 0;

    for (Boid other : boids) {
      if (this.isSameSpecies(other) || Flocking.desireAssociation != 0 && this.isPrey() ) {
        float d = PVector.dist(position, other.position);
        if ((d > 0) && (d < neighbordist)) {
          sum.add(other.position); // Add position
          count++;
        }
      }
    }

    if (count > 0) {
      sum.div(count);
      return seek(sum);  // Steer towards the position
    } else {
      return new PVector(0, 0);
    }
  }

  @Override public 
    PVector separate (ArrayList<Boid> boids) {
    float desiredseparation = 25.0f;
    PVector steer = new PVector(0, 0, 0);
    int count = 0;
    for (Boid other : boids) {
      if (other.isPrey()) {
        desiredseparation=desiredSeparationPrey;
      }
      if (other.isPredator()) {
        desiredseparation=desiredSeparationPredator;
      }
      float d = PVector.dist(position, other.position);
      if ((d > 0) && (d < desiredseparation)) {
        PVector diff = PVector.sub(position, other.position);
        diff.normalize();
        diff.div(d);        // Weight by distance
        steer.add(diff);
        count++;            // Keep track of how many
      }
    }
    //moyenne
    if (count > 0) {
      steer.div((float)count);
    }
    if (steer.mag() > 0) {
      steer.normalize();
      steer.mult(maxspeed);
      steer.sub(velocity);
      steer.limit(maxforce);
    }
    return steer;
  }
}
class Savana {
  ArrayList<Boid> boids;// An ArrayList for all the boids
  PVector wCenter;

  Savana() {
    boids = new ArrayList<Boid>(); // Initialize the ArrayList
  }
  
  public ArrayList<Prey> getPreys() {

    ArrayList<Prey> listePrey = new ArrayList<Prey>();
    for (Boid b : boids) {
      if (b.isPrey()) {
        listePrey.add((Prey) b);
      }
    }
    return listePrey;
  }

  public ArrayList<Prey> getWildebeests() {
    ArrayList<Prey> w = new ArrayList<Prey>();
    for (Prey p : getPreys()) {
      if (p.isWildebeest()) {
        w.add(p);
      }
    }
    return w;
  }

  public ArrayList<Prey> getZebras() {
    ArrayList<Prey> w = new ArrayList<Prey>();
    for (Prey p : getPreys()) {
      if (p.isZebra()) {

        w.add(p);
      }
    }
    return w;
  }

  public ArrayList<Predator> getCheetahs() {
    ArrayList<Predator> w = new ArrayList<Predator>();
    for (Predator p : getPredators()) {
      if (p.isCheetah()) {

        w.add(p);
      }
    }
    return w;
  }


  public PVector wildebeestCenter() {
    ArrayList<Prey> wildebeests = getWildebeests();
    int N=wildebeests.size();
    PVector C = new PVector(0, 0);
    for (Prey w : wildebeests) {
      C = C.add(w.position);
    }
    if (N!=0) {
      //float NFloat = (float)N;
      C = C.mult(1.0f/N);
      println("----->>>>>>" + C.x + ", " + C.y);
      return C;
    } else {
      println("------>>>>> !!!!! returning C = 0");
      return C.mult(0);
    }
  }

  public Prey MostIsolateWildebeest() {
    PVector center = wildebeestCenter();
    ArrayList<Prey> wflock = getWildebeests();
    int imin =0;
    float dMin= distanceTo(wflock.get(0), center);
    /*
   for(Prey w : wflock){
     float d = distanceTo(w,center);
     if(d<dMin){
     i++;
     }
     }
     return wflock.get(i);*/

    for (int i =0; i<wflock.size(); i++) {
      if (distanceTo(wflock.get(i), center)<dMin) {
        imin=i;
        dMin=distanceTo(wflock.get(i), center);
      }
    }
    return wflock.get(imin);
  }

  public float distanceTo(Boid boid, PVector point) {
    return PVector.sub(boid.position, point).mag();
  }

  public ArrayList<Predator> getPredators() {
    ArrayList<Predator> listePred = new ArrayList<Predator>();
    for (Boid b : boids) {
      if (!b.isPrey()) {
        listePred.add((Predator) b);
      }
    }
    return listePred;
  }

  public void remove(Boid b) {
    boids.remove(b);
  }

  public int number() {
    return boids.size();
  }

  public void run() {
    this.wCenter = wildebeestCenter();
    render();

    for (int i=0; i<boids.size(); i++) {

      Boid b = boids.get(i);


      b.run(boids);
    }
  }

  public int NumberOfCheetahs() {
    int c=0;
    for (Boid b : boids) {
      if (b.isCheetah()) {
        c++;
      }
    }
    return c;
  }

  public int NumberOfZebras() {
    int c=0;
    for (Boid b : boids) {
      if (b.isZebra()) {
        c++;
      }
    }
    return c;
  }

  public int NumberOfWildebeests() {
    int c=0;
    for (Boid b : boids) {
      if (b.isWildebeest()) {
        c++;
      }
    }
    return c;
  }
  public int size() {
    return boids.size();
  }

  public void addBoid(Boid b) {
    boids.add(b);
  }

  float rz = 4;

  public void render() {
    PVector position = wCenter;
    // Draw a triangle rotated in the direction of velocity
    float theta =position.heading() + radians(90);
    // heading2D() above is now heading() but leaving old syntax until Processing.js catches up


    fill(185, 42, 76);
    stroke(7);
    pushMatrix();
    translate(position.x, position.y);
    rotate(theta);
    beginShape(QUAD);
    vertex(0, -rz*2);
    vertex(-rz*2, 0);
    vertex(0, rz*2);
    vertex(rz*2, 0);
    endShape();
    popMatrix();

  }
}
/**
 * Stores a bunch of stats
 */
class StatTracker {

  private boolean toggleLogging = false;

  /********** CORE FIELDS **********/

  Savana savana;
  private int frameDelta;        // Keeps track of the frames since last refresh
  private final int refreshRate; // Number of frames in between two information-fetching, adjust to prevent lag
  private FloatList graphAbsciss;
  boolean isStarted;

  /********** DATA FIELDS **********/

  private IntList entityCount;
  private IntList wildebeestCount;
  private IntList zebraCount;
  private IntList predatorCount;
  private FloatList lifetime;    // List of lifetime by each dead boids
  private IntList tmpLifetime;

  /********** CONSTRUCTORS **********/

  StatTracker (Savana savana, int refreshRate) {

    this.savana = savana;
    this.refreshRate = refreshRate;
    frameDelta = 0;
    graphAbsciss = new FloatList();
    isStarted = false;

    // Initializes data
    entityCount = new IntList();
    wildebeestCount = new IntList();
    zebraCount = new IntList();
    predatorCount = new IntList();
    lifetime = new FloatList();
    tmpLifetime = new IntList();
  }

  /********** REFRESH METHODS **********/

  // CORE METHODS

  public void refresh () {

    if (!isStarted) return;
    
    frameDelta++;
    getLifetimes();

    if (frameDelta < refreshRate) return;
    else {

      if (toggleLogging) System.out.println( "STATTRACKER - Refreshing, interation " + str( PApplet.parseInt( frameCount/refreshRate ) ) );

      fetchData();
      frameDelta = 0;
      
      graphAbsciss.append( frameCount );
    }
  }

  public void fetchData() {

    if (toggleLogging) System.out.println( "STATTRACKER - Fetching Data" );
    
    fetchEntityCount();
    fetchWildebeestCount();
    fetchZebraCount();
    fetchPredatorCount();

    fetchLifetime();
  }
  
  public void startTracking() { isStarted = true; }

  /********** GRAPH MANAGEMENT **********/
  
  public void renderGraphs() {
    
    if (!isStarted) return;
    
    // ENTITYCOUNT
    
    Graph entityCountGraph = new Graph( 1000 , 680 , 240 , 180 , 25 );
    
    FloatList FLentityCount = new FloatList();
    for (int i=0 ; i<entityCount.size() ; i++) FLentityCount.append( (float) entityCount.get(i) );
    
    entityCountGraph.fillData ( graphAbsciss.copy() , FLentityCount );
    
    // WILDEBEESTS
    
    TransparentGraph wildebeestCountGraph = new TransparentGraph( 1000 , 680 , 240 , 180 , 25 , entityCountGraph );
    wildebeestCountGraph.setCurveColor( 245, 198, 215 );
    
    FloatList FLwildebeestCount = new FloatList();
    for (int i=0 ; i<entityCount.size() ; i++) FLwildebeestCount.append( (float) wildebeestCount.get(i) );
    
    wildebeestCountGraph.fillData ( graphAbsciss.copy() , FLwildebeestCount );
    
    // ZEBRAS
    
    TransparentGraph zebraCountGraph = new TransparentGraph( 1000 , 680 , 240 , 180 , 25 , entityCountGraph );
    zebraCountGraph.setCurveColor( 0, 128, 0 );
    
    FloatList FLzebraCount = new FloatList();
    for (int i=0 ; i<entityCount.size() ; i++) FLzebraCount.append( (float) zebraCount.get(i) );
    
    zebraCountGraph.fillData ( graphAbsciss.copy() , FLzebraCount );
    
    // PREDATORS
    
    TransparentGraph predatorCountGraph = new TransparentGraph( 1000 , 680 , 240 , 180 , 25 , entityCountGraph );
    predatorCountGraph.setCurveColor( 220 , 50 , 50 );
    
    FloatList FLpredatorCount = new FloatList();
    for (int i=0 ; i<entityCount.size() ; i++) FLpredatorCount.append( (float) predatorCount.get(i) );
    
    predatorCountGraph.fillData ( graphAbsciss.copy() , FLpredatorCount );
    
    // RENDERING
    
    entityCountGraph.render();
    wildebeestCountGraph.render();
    zebraCountGraph.render();
    predatorCountGraph.render();
    
  }

  /********** SAVING METHODS **********/

  public boolean saveEntityCounts() {

    if (toggleLogging) System.out.println( "STATTRACKER - Saving Entity Counts" );

    System.out.println( "Saving" );

    JSONObject json = entityCountsToJSON();

    try {

      if (toggleLogging) System.out.println( "STATTRACKER - Attempting to save JSON Entity Counts file" );
      saveJSONObject( json, "data/entityCounts.json" );
    }
    catch (Exception ex) {

      return false;
    }

    return true;
  }

  private JSONObject entityCountsToJSON () {

    if (toggleLogging) System.out.println( "STATTRACKER - Converting Entity Counts to JSON" );

    if (toggleLogging) printCounts();

    JSONObject json = new JSONObject();

    for ( int i = 0; i < entityCount.size(); i ++ ) {

      json.setString( "entities" + str(i), str( entityCount.get(i) ) );
      json.setString( "preys" + str(i), str( wildebeestCount.get(i) ) );
      json.setString( "predators" + str(i), str( predatorCount.get(i) ) );
      json.setString( "lifetime" + str(i), str( lifetime.get(i) ) );
    }

    return json;
  }

  private void printCounts() {

    String entityCountStr = "entityCount : [ ";

    for (int i = 0; i<entityCount.size(); i++) entityCountStr += ( str(entityCount.get(i)) + " , " );

    System.out.println( entityCountStr );

    // *********************

    String wildebeestCountStr = "wildebeestCount : [ ";

    for (int i = 0; i<wildebeestCount.size(); i++) wildebeestCountStr += ( str(wildebeestCount.get(i)) + " , " );

    System.out.println( wildebeestCountStr );

    // *********************

    String predatorCountStr = "entityCount : [ ";

    for (int i = 0; i<predatorCount.size(); i++) predatorCountStr += ( str(predatorCount.get(i)) + " , " );

    System.out.println( predatorCount );
  }

  /********** REFRESH SUB-METHODS **********/

  public void fetchEntityCount() {

    if (toggleLogging) System.out.println( "STATTRACKER - Fetching Data - entityCount" );
    entityCount.append( savana.boids.size() );
  }

  public void fetchWildebeestCount() {

    if (toggleLogging) System.out.println( "STATTRACKER - Fetching Data - wildebeestCount" );

    wildebeestCount.append( savana.getWildebeests().size() );
  }
  
  public void fetchZebraCount() {
    
    if (toggleLogging) System.out.println( "STATRACKER - Fetching Data - zebraCount" );
    
    zebraCount.append( savana.getZebras().size() );
    
  }

  public void fetchPredatorCount() {

    if (toggleLogging) System.out.println( "STATTRACKER - Fetching Data - predatorCount" );

    predatorCount.append( savana.getPredators().size() );
  }

  /**
   * Stores the lifetimes of boids dead during the frame into the temporary list
   */
  public void getLifetimes() {

    for (Boid boid : savana.boids) {

      if (!boid.isAlive()) tmpLifetime.append( boid.lifetime );
    }
  }

  /**
   * Empties the tmp lifetime list and stores its avergae in the lifetime IntList
   */
  public void fetchLifetime() {

    if (toggleLogging) System.out.println( "STATRACKER - Fetching Data - lifeTime" );

    float avg = 0;

    for ( int i : tmpLifetime ) avg += i;

    avg /= tmpLifetime.size();

    int iterations = lifetime.size();

    if (iterations != 0) {

      lifetime.append( ( iterations * lifetime.get( iterations - 1 ) + avg ) / ( iterations + 1 ) );
    } else {
      lifetime.append ( avg );
    }

    tmpLifetime.clear();
  }
}
class StudyCheetah extends Cheetah{
  
  
  StudyCheetah(float x,float y){
    super(x,y);}
    
    
    @Override public 
     void render() {
    // Draw a triangle rotated in the direction of velocity
    float theta = velocity.heading() + radians(90);
    // heading2D() above is now heading() but leaving old syntax until Processing.js catches up
    if(this.hasAPrey){
    fill(238, 241,22);
    noStroke();
    pushMatrix();
    translate(position.x, position.y);
    rotate(theta);
    beginShape(TRIANGLES);
    vertex(0, -r*2);
    vertex(-r, r*2);
    vertex(r, r*2);
    endShape();
    popMatrix();}
    else{
       fill(136, 144,41);
    noStroke();
    pushMatrix();
    translate(position.x, position.y);
    rotate(theta);
    beginShape(TRIANGLES);
    vertex(0, -r*2);
    vertex(-r, r*2);
    vertex(r, r*2);
    //le faisceau de vision
    vertex(0, -r*2);
    vertex(sin(alpha/2)*rangeVision,cos(alpha)*(-rangeVision)-r*2);
    vertex(-sin(alpha/2)*rangeVision,cos(alpha)*(-rangeVision)-r*2);
   
    endShape();
    popMatrix();}
    
   
  }
  
}
/*
import java.util.Map;

class SwarmDraws{
  ArrayList<Prey> wildebeests;
  ArrayList<Predator> cheetahs;
  ArrayList<Prey> zebras;
  float r = 4;
  PVector wCenter;
  
  SwarmDraws(Savana savana){
    this.wildebeests = savana.getWildebeests();
    this.zebras = savana.getZebras();
    this.cheetahs = savana.getCheetahs();
    this.wCenter = new PVector(0,0);
  }
  
  
  
  
  void run(){
   this.wCenter = savana.wildebeestCenter();
    render();}
    
    
  
void render() {
  PVector position = wCenter;
    // Draw a triangle rotated in the direction of velocity
    float theta =position.heading() + radians(90);
    // heading2D() above is now heading() but leaving old syntax until Processing.js catches up

  
       fill(185, 42,76);
    stroke(7);
    pushMatrix();
    translate(position.x, position.y);
    rotate(theta);
    beginShape(QUAD);
    vertex(0, -r*2);
    vertex(-r*2,0);
    vertex(0, r*2);
    vertex(r*2,0);
    endShape();
    popMatrix();
    }
  
/*ArrayList<Prey> sortedByDistance(){
  PVector C = wildebeestCenter();
  FloatList D = new FloatList();
  HashMap<Prey, float> pd = new HashMap<Prey, float>();
  for(Prey p : wildebeests){
    float d = p.distanceTo(C);
    D.append(d);
    pd.put(p,d);
  }
  D.sort();
  ArrayList<Prey> S = new ArrayList<Prey>();
  for(float d : D){
    S.add(pd.get(d));
  }
  return S; 
  
  
  
}*/
  
  
class TransparentGraph extends Graph {
  
  Graph leadGraph;
  
  TransparentGraph( PVector graphOrigin , int graphWidth , int graphHeight , int margin , Graph leadGraph) {
    super ( graphOrigin , graphWidth , graphHeight , margin );
    this.leadGraph = leadGraph;
  }
  
  TransparentGraph( int xCoord , int yCoord , int graphWidth , int graphHeight , int margin , Graph leadGraph) {
    super ( xCoord , yCoord , graphWidth , graphHeight , margin );
    this.leadGraph = leadGraph;
  }
  
  @Override public 
  void renderBackground() { return; }
  
  @Override public 
  boolean[] refreshDistortion() {
    if (toggleLogging) System.out.println(printType() + " - Fetching distortion fields");
    float[] tmp = leadGraph.getDistortion();
    
    xDistortion = tmp[0];
    yDistortion = tmp[1];
    
    return leadGraph.getAxisToDistort();
    
  }
  
  @Override public 
  String printType() { return "TransparentGraph"; }
  
}
/** classe des gnous **/

class Wildebeest extends Prey {

  float r=2; //taille du gnou

  float maxforce=0.01f; //force maximale applicable au gnou

  float maxspeed=0; // vitesse maximale acceptee

  float rangeVision=50; // champ de vision

  boolean alive; // true si le bdi est en vie

  float rangeAudition; // champ d'audition


  /** Constructeur de la classe des gnous **/
  Wildebeest(float x, float y) {
    super(x, y, 2, 0.03f, 2, 100, 100);
  }

  /** Determine l'apparence des gnous en fonction de si ils sont isolés ou pas, afin de mieux voir les proies vite attaquées par les predateurs **/

  public void render() {
    float theta = velocity.heading() + radians(90);
    if (this.isIsolated) {
      fill(245, 198, 215);
      stroke(255);
      pushMatrix();
      translate(position.x, position.y);
      rotate(theta);
      beginShape(QUAD);
      vertex(0, -r*2);
      vertex(-r*2, 0);
      vertex(0, r*2);
      vertex(r*2, 0);
      endShape();
      popMatrix();
    }
    if (!this.isIsolated) {
      fill(14, 36, 173);
      stroke(255);
      pushMatrix();
      translate(position.x, position.y);
      rotate(theta);
      beginShape(QUAD);
      vertex(0, -r*2);
      vertex(-r*2, 0);
      vertex(0, r*2);
      vertex(r*2, 0);
      endShape();
      popMatrix();
    }
  }

  @Override public 
    boolean isWildebeest() {
    return true;
  }
  
  @Override public 
  boolean isSameSpecies(Boid other) { return other.isWildebeest(); }
}
//classe des zebres

class Zebra extends Prey {

  /** Constructeur de la classe des zebres 
  *@param x,y la position initiale **/
  
  Zebra(float x, float y) {
    super(x, y, 2, 0.03f, 4, 500, 100);
  }
  
  /**Methode pour mettre a jour l'apparence des zebres **/
  
  public void render() {
    float theta = velocity.heading() + radians(90);
    fill(0, 128, 0);
    stroke(255);
    pushMatrix();
    translate(position.x, position.y);
    rotate(theta);
    beginShape(TRIANGLES);
    vertex(0, -r*2);
    vertex(-r, r*2);
    vertex(r, r*2);
    endShape();
    popMatrix();
  }

  /** Methode pour mettre a jour le comportement des zebres 
  *@param boids la liste des boids autour **/
  
  public void behavior(ArrayList<Boid> boids) {
    PVector sep = separate(boids);   // Separation
    PVector ali = align(boids);      // Alignment
    PVector coh = cohesion(boids);   // Cohesion
    // Arbitrarily weight these forces
    sep.mult(1.5f);
    ali.mult(1.0f);
    coh.mult(1.0f);
    // Add the force vectors to acceleration
    applyForce(sep);
    applyForce(ali);
    applyForce(coh);
  }

  @Override public 
  boolean isZebra() {
    return true;
  }
  
  @Override public 
  boolean isSameSpecies(Boid other) { return other.isZebra(); }
}


  public void settings() { size(640*2, 360*2); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Flocking" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
